#
# Lib functions to generate, import and encrypt secrets. At the
# moment we use Age for encryption and we only deal with passwords
# and TLS certificates. See functions below.
#

: "${BASE_DIR:=vault}"

passwords_dir="${BASE_DIR}/passwords"
certs_dir="${BASE_DIR}/certs"
ssh_dir="${BASE_DIR}/ssh"
age_key_file="${BASE_DIR}/age.key"
ssh_id="${ssh_dir}/id_ed25519"

#
# Create the directories where to output all the generated files.
#
make_dirs() {
    mkdir -p "${passwords_dir}"
    mkdir -p "${certs_dir}"
    mkdir -p "${ssh_dir}"
}

#
# Generate an ED25519 key pair (identity) with no comment and passphrase.
# Skip if the identity file already exists.
#
make_ssh_id() {
    if [ ! -f "${ssh_id}" ]; then
        ssh-keygen -t ed25519 -C '' -q -N '' -f "${ssh_id}"
    fi
}
# NOTE
# ----
# 1. Pub key. The above command generates a `.pub` key file with the
# pub key in it. You can always extract the pub key from the private
# with `ssh-keygen -y -f your_pvt_key`.
# 2. OpenSSL. You could use OpenSSL to generate keys too. E.g.
#   $ openssl genpkey -algorithm ed25519 -out id.pem
#   $ openssl pkey -in id.pem -pubout -out id-pub.pem
# But the pub key won't be in the same OpenSSH format, which is why
# we use `ssh-keygen` instead.

#
# Generate an Age key (identity) to encrypt/decrypt data.
# Skip if the identity file already exists.
#
make_age_key() {
    if [ ! -f "${age_key_file}" ]; then
        age-keygen -o "${age_key_file}"
    fi
}

#
# Encrypt the given file with `age`, using the Age key generated
# by `make_age_key`. Write the encrypted file to `${in_file}.age`,
# where `in_file` is the input file path. For instance if the input
# file path `passwords/admin`, then the encrypted file will be
# `passwords/admin.age`.
#
# Args:
# - Input file path. The path to the file to encrypt.
#
encrypt() {
    local in_file="$1"

    local recipient=$(age-keygen -y "${age_key_file}")
    age -o "${in_file}.age" -r $recipient "${in_file}"
}

#
# Given a clear-text password, output the corresponding password
# files in the passwords dir:
#
# - Clear text. A file containing the password in clear text.
# - Age. A file containing the password encrypted using `age`
#   and the `age` key automatically generated by this script.
# - SHA512. A file containing a SHA512 hash of the password
#   `chpasswd` can handle.
# - SHA512 Age. A file containing the SHA512 hash encrypted
#   using `age` and the `age` key automatically generated by
#   this script.
# - Yescrypt. A file containing a Yescrypt hash of the password
#   `chpasswd` can handle.
# - Yescrypt Age. A file containing the Yescrypt hash encrypted
#   using `age` and the `age` key automatically generated by
#   this script.
#
# Args:
# - File name. The name of the file where to write the clear text
#   password. Output generated files with the same base name plus
#   `.sha512`, `.sha512.age`, `.yesc`, `.yesc.age` extensions according
#   to output type. For instance if `admin` is the file name, then
#   the clear text file name will be `admin`, the SHA512 and Yescrypt
#   ones will be, respectively, `admin.sha512` and `admin.yesc` whereas
#   the corresponding Age files will be `admin.age`, `admin.sha512.age`,
#   and `admin.yesc.age`, respectively.
# - Clear text password. The password to use. If none given, generate
#   a strong, memorable one.
#
make_password_files() {
    local file_name="$1"
    local clear_text="${2:-}"
    local base_file="${passwords_dir}/${file_name}"

    if [ -z "${clear_text}" ]; then
        clear_text=$(diceware)
    fi
    echo "${clear_text}" > "${base_file}"
    printf "${clear_text}" | mkpasswd -m sha-512 -s > "${base_file}.sha512"
    printf "${clear_text}" | mkpasswd -m yescrypt -s > "${base_file}.yesc"

    encrypt "${base_file}"
    encrypt "${base_file}.sha512"
    encrypt "${base_file}.yesc"
}

#
# Generate a basic self-signed, 100-year valid, RSA SSL certificate
# in PEM format and put it into the certs dir. Write the public cert
# to `${domain}-cert.pem` and the private key to `${domain}-key.pem`,
# where `domain` is the domain name. Also encrypt each file with `age`
# and the Age key automatically generated by this script. Write each
# encrypted file to a file with the same name plus the `.age` extension.
#
# Args:
# - Domain name. The CN name for the certificate to generate.
#
make_cert_files() {
    local domain="$1"
    local cert="${certs_dir}/${domain}-cert.pem"
    local key="${certs_dir}/${domain}-key.pem"

    openssl req -x509 -newkey rsa:4096 -days 36500 -nodes \
        -subj "/CN=${domain}" \
        -keyout "${key}" -out "${cert}" 2> /dev/null

    encrypt "${cert}"
    encrypt "${key}"
}

#
# Copy TLS pub cert and key over to the certs dir and encrypt the key.
# Encrypt with `age` and the Age key automatically generated by this
# script. Write the encrypted key to a file with the same name plus
# the `.age` extension.
#
# Args:
# - Public certificate. Path to the certificate file.
# - Certificate key. Path to the certificate's private key file.
#
import_cert_files() {
    local cert="$1"
    local key="$2"
    local cert_basename=$(basename "${cert}")
    local key_basename=$(basename "${key}")

    cp "${cert}" "${certs_dir}/"
    cp "${key}" "${certs_dir}/"
    encrypt "${certs_dir}/${cert_basename}"
    encrypt "${certs_dir}/${key_basename}"
}

make_gitignore() {
    local age_identity=$(basename "${age_key_file}")
    local certs=$(basename "${certs_dir}")
    local passwords=$(basename "${passwords_dir}")
    local ssh=$(basename "${ssh_dir}")

    cat <<EOF > "${BASE_DIR}/.gitignore"
# Ignore the Age identity
/${age_identity}

# Ignore everything in ${certs} except for Age-encrypted files.
/${certs}/*
!/${certs}/*.age

# Ignore everything in ${passwords} except for Age-encrypted files.
/${passwords}/*
!/${passwords}/*.age

# Ignore everything in ${ssh} except for public key files.
/${ssh}/*
!/${ssh}/*.pub

EOF
}