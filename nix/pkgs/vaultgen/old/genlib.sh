#
# Lib functions to generate, import and encrypt secrets. At the
# moment we use Age for encryption and we only deal with passwords
# and TLS certificates. See functions below.
#

: "${BASE_DIR:=vault}"

passwords_dir="${BASE_DIR}/passwords"
certs_dir="${BASE_DIR}/certs"
ssh_dir="${BASE_DIR}/ssh"
age_key_file="${BASE_DIR}/age.key"
ssh_id="${ssh_dir}/id_ed25519"

#
# Create the directories where to output all the generated files.
#
make_dirs() {
    mkdir -p "${passwords_dir}"
    mkdir -p "${certs_dir}"
    mkdir -p "${ssh_dir}"
}

#
# Generate an ED25519 key pair (identity) with no comment and passphrase.
# Skip if the identity file already exists.
#
make_ssh_id() {
    if [ ! -f "${ssh_id}" ]; then
        ssh-keygen -t ed25519 -C '' -q -N '' -f "${ssh_id}"
    fi
}
# NOTE
# ----
# 1. Pub key. The above command generates a `.pub` key file with the
# pub key in it. You can always extract the pub key from the private
# with `ssh-keygen -y -f your_pvt_key`.
# 2. OpenSSL. You could use OpenSSL to generate keys too. E.g.
#   $ openssl genpkey -algorithm ed25519 -out id.pem
#   $ openssl pkey -in id.pem -pubout -out id-pub.pem
# But the pub key won't be in the same OpenSSH format, which is why
# we use `ssh-keygen` instead.

#
# Generate an Age key (identity) to encrypt/decrypt data.
# Skip if the identity file already exists.
#
make_age_key() {
    if [ ! -f "${age_key_file}" ]; then
        age-keygen -o "${age_key_file}"
    fi
}

#
# Encrypt the given file with `age`, using the Age key generated
# by `make_age_key`. Write the encrypted file to `${in_file}.age`,
# where `in_file` is the input file path. For instance if the input
# file path `passwords/admin`, then the encrypted file will be
# `passwords/admin.age`.
#
# Args:
# - Input file path. The path to the file to encrypt.
#
encrypt() {
    local in_file="$1"

    local recipient=$(age-keygen -y "${age_key_file}")
    age -o "${in_file}.age" -r $recipient "${in_file}"
}

#
# Given a clear-text password, output the corresponding password
# files in the passwords dir:
#
# - Clear text. A file containing the password in clear text.
# - Age. A file containing the password encrypted using `age`
#   and the `age` key automatically generated by this script.
# - SHA512. A file containing a SHA512 hash of the password
#   `chpasswd` can handle.
# - SHA512 Age. A file containing the SHA512 hash encrypted
#   using `age` and the `age` key automatically generated by
#   this script.
# - Yescrypt. A file containing a Yescrypt hash of the password
#   `chpasswd` can handle.
# - Yescrypt Age. A file containing the Yescrypt hash encrypted
#   using `age` and the `age` key automatically generated by
#   this script.
#
# Args:
# - File name. The name of the file where to write the clear text
#   password. Output generated files with the same base name plus
#   `.sha512`, `.sha512.age`, `.yesc`, `.yesc.age` extensions according
#   to output type. For instance if `admin` is the file name, then
#   the clear text file name will be `admin`, the SHA512 and Yescrypt
#   ones will be, respectively, `admin.sha512` and `admin.yesc` whereas
#   the corresponding Age files will be `admin.age`, `admin.sha512.age`,
#   and `admin.yesc.age`, respectively.
# - Clear text password. The password to use. If none given, generate
#   a strong, memorable one.
#
make_password_files() {
    local file_name="$1"
    local clear_text="${2:-}"
    local base_file="${passwords_dir}/${file_name}"

    if [ -z "${clear_text}" ]; then
        clear_text=$(diceware)
    fi
    printf "${clear_text}" > "${base_file}"
    printf "${clear_text}" | mkpasswd -m sha-512 -s > "${base_file}.sha512"
    printf "${clear_text}" | mkpasswd -m yescrypt -s > "${base_file}.yesc"

    encrypt "${base_file}"
    encrypt "${base_file}.sha512"
    encrypt "${base_file}.yesc"
}

#
# Generate a simple certificate set in the certs dir or do nothing
# if the set is there already.
# Generate the cert as a 100-valid, RSA x509 cert in PEM format. If
# given a CA key and cert, then use them to sign the generated cert;
# otherwise self-sign it.
# Write the generated public cert to `${cn}-cert.pem` and its private
# key to `${cn}-key.pem`, where `cn` is the given CN name.
# Also encrypt each file with `age` and the Age key automatically
# generated by this script. Write each encrypted file to a file in
# the certs dir with the same name plus the `.age` extension.
#
# Args:
# - CN. The CN name for the certificate to generate.
# - CA key. Optional CA key file to sign the certificate. If given,
#   the CA certificate must be given too.
# - CA cert. Optional CA cert file to sign the generated certificate.
#
make_cert_file_set() {
    local cn="$1"
    local key="${certs_dir}/${cn}-key.pem"
    local cert="${certs_dir}/${cn}-cert.pem"

    if [ -f "${cert}" ]; then
        return 0
    fi

    if (( $# > 1 )); then
        local ca_key="$2"
        local ca_cert="$3"

        openssl req -x509 -newkey rsa:4096 -days 36500 -nodes \
            -subj "/CN=${cn}" \
            -keyout "${key}" -out "${cert}" \
            -CAkey "${ca_key}" -CA "${ca_cert}" 2> /dev/null
    else
        openssl req -x509 -newkey rsa:4096 -days 36500 -nodes \
            -subj "/CN=${cn}" \
            -keyout "${key}" -out "${cert}" 2> /dev/null
    fi

    encrypt "${key}"
    encrypt "${cert}"
}

#
# Generate CA and domain certificates in the certs dir.
# Generate each certificate as a 100-valid, RSA x509 certificate in
# PEM format. Self-sign the CA certificate but use that CA to sign
# every domain certificate.
# Write the CA public cert to `${name}-cert.pem` and its private key
# to `${name}-key.pem`, where `name` is the given CA name.
# Likewise, Write each public cert to `${domain}-cert.pem` and its
# private key to `${domain}-key.pem`, where `domain` is the domain
# name.
# Also encrypt each file with `age` and the Age key automatically
# generated by this script. Write each encrypted file to a file with
# the same name plus the `.age` extension.
# Finally if the CA files are there don't generate them again. Ditto
# for certificates. This way you can easily add new certs to your
# stash and sign them with the existing CA. But keep in mind if you
# remove the CA files, then you should zap all the certs that were
# signed with that CA too as we don't check that. For example, if
# you delete the CA files but keep a certificate for `my.dom`, the
# CA files get generated again, but the `my.dom` files will still
# be the ones signed with the old CA.
#
# Args:
# - CA name. The CN name for the CA certificate to generate.
# - Domain names. A list of CN names, one for each domain certificate
#   to generate.
#
make_cert_files() {
    local ca_cn="$1"
    local ca_key="${certs_dir}/${ca_cn}-key.pem"
    local ca_cert="${certs_dir}/${ca_cn}-cert.pem"
    make_cert_file_set "${ca_cn}"

    shift 1
    for domain in "$@"; do
        make_cert_file_set "${domain}" "${ca_key}" "${ca_cert}"
    done
}

#
# Copy TLS pub cert and key over to the certs dir and encrypt the key.
# Encrypt with `age` and the Age key automatically generated by this
# script. Write the encrypted key to a file with the same name plus
# the `.age` extension.
#
# Args:
# - Public certificate. Path to the certificate file.
# - Certificate key. Path to the certificate's private key file.
#
import_cert_files() {
    local cert="$1"
    local key="$2"
    local cert_basename=$(basename "${cert}")
    local key_basename=$(basename "${key}")

    cp "${cert}" "${certs_dir}/"
    cp "${key}" "${certs_dir}/"
    encrypt "${certs_dir}/${cert_basename}"
    encrypt "${certs_dir}/${key_basename}"
}

make_gitignore() {
    local age_identity=$(basename "${age_key_file}")
    local certs=$(basename "${certs_dir}")
    local passwords=$(basename "${passwords_dir}")
    local ssh=$(basename "${ssh_dir}")

    cat <<EOF > "${BASE_DIR}/.gitignore"
# Ignore the Age identity
/${age_identity}

# Ignore everything in ${certs} except for Age-encrypted files.
/${certs}/*
!/${certs}/*.age

# Ignore everything in ${passwords} except for Age-encrypted files.
/${passwords}/*
!/${passwords}/*.age

# Ignore everything in ${ssh} except for public key files.
/${ssh}/*
!/${ssh}/*.pub

EOF
}